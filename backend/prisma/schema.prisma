// SplitSahiSe - Prisma Schema
// PostgreSQL with strict FK relationships for expense splitting app

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============== USER & AUTH ==============

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified Boolean   @default(false)
  name          String
  phone         String?   @unique
  phoneVerified Boolean   @default(false)
  passwordHash  String?   // For JWT auth; null if using Clerk/OAuth
  clerkId       String?   @unique // For Clerk auth
  oauthProvider String?   // 'google', 'apple', etc.
  oauthId       String?   // OAuth provider's user ID
  avatarUrl     String?
  upiId         String?   // UPI ID for Indian payments (e.g. user@paytm)
  currency      String    @default("INR")
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  createdGroups     Group[]         @relation("GroupCreator")
  groupMemberships  GroupMember[]
  friendshipsInit   Friendship[]    @relation("FriendshipRequester")
  friendshipsRecv   Friendship[]    @relation("FriendshipReceiver")
  expensesCreated   Expense[]       @relation("ExpenseCreator")
  expensePayers     ExpensePayer[]
  expenseSplits     ExpenseSplit[]
  expenseParticipants ExpenseParticipant[]
  settlementsFrom   Settlement[]    @relation("SettlementFrom")
  settlementsTo     Settlement[]    @relation("SettlementTo")
  recurringExpenses RecurringExpense[]
  
  @@index([email])
  @@index([phone])
}

// ============== FRIENDSHIP ==============

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

model Friendship {
  id         String           @id @default(cuid())
  requesterId String
  receiverId  String
  status     FriendshipStatus @default(PENDING)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt

  requester User @relation("FriendshipRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  receiver  User @relation("FriendshipReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([requesterId, receiverId])
  @@index([requesterId, receiverId])
  @@index([receiverId])
}

// ============== GROUPS ==============

model Group {
  id          String    @id @default(cuid())
  name        String
  description String?
  imageUrl    String?
  currency    String    @default("INR")
  createdById String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  creator User         @relation("GroupCreator", fields: [createdById], references: [id], onDelete: Cascade)
  members GroupMember[]
  expenses Expense[]
  settlements Settlement[]
  recurringExpenses RecurringExpense[]
}

enum GroupMemberRole {
  ADMIN
  MEMBER
}

model GroupMember {
  id        String          @id @default(cuid())
  groupId   String
  userId    String
  role      GroupMemberRole @default(MEMBER)
  joinedAt  DateTime        @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([userId])
}

// ============== EXPENSES ==============

enum SplitType {
  EQUAL      // Split equally among participants
  EXACT      // Each person owes exact amount
  PERCENTAGE // Split by percentage
  SHARE      // Split by shares (e.g. 1:2:1)
}

enum RecurringFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

model RecurringExpense {
  id           String             @id @default(cuid())
  title        String
  description  String?
  amount       Decimal            @db.Decimal(12, 2)
  category     String             @default("Other")
  frequency    RecurringFrequency
  startDate    DateTime           @default(now())
  nextRunDate  DateTime
  lastRunDate  DateTime?
  isActive     Boolean            @default(true)
  
  groupId      String?
  createdById  String
  splitType    SplitType
  participants Json               // Store array of user IDs
  splits       Json?              // Store split logic (percentages/amounts)
  
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  group        Group?             @relation(fields: [groupId], references: [id], onDelete: SetNull)
  creator      User               @relation(fields: [createdById], references: [id], onDelete: Cascade)
  
  @@index([nextRunDate])
}

model Expense {
  id           String    @id @default(cuid())
  groupId      String?   // Null = friend-to-friend expense
  title        String
  description  String?
  category     String    // e.g. Food, Travel; used for smart categorization
  totalAmount  Decimal   @db.Decimal(12, 2)
  currency     String    @default("INR")
  imageUrl     String?
  splitType    SplitType
  createdById  String
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  expenseDate  DateTime  @default(now()) // When the expense occurred

  group    Group?                @relation(fields: [groupId], references: [id], onDelete: Cascade)
  creator  User                  @relation("ExpenseCreator", fields: [createdById], references: [id], onDelete: Cascade)
  payers   ExpensePayer[]
  splits   ExpenseSplit[]
  participants ExpenseParticipant[]

  @@index([groupId])
  @@index([createdById])
  @@index([createdAt])
}

// Who paid how much for this expense (multiple payers supported)
model ExpensePayer {
  id         String   @id @default(cuid())
  expenseId  String
  userId     String
  amountPaid Decimal  @db.Decimal(12, 2)

  expense Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([expenseId, userId])
  @@index([userId])
}

// Who owes how much for this expense
model ExpenseSplit {
  id         String   @id @default(cuid())
  expenseId  String
  userId     String
  amountOwed Decimal  @db.Decimal(12, 2) // Computed share for this user
  percentage Decimal? @db.Decimal(5, 2)  // For PERCENTAGE split
  shares     Int?     // For SHARE split (e.g. 1, 2, 1)

  expense Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([expenseId, userId])
  @@index([userId])
}

// Participants in an expense (for group expenses = subset of group; for friend expense = explicit list)
model ExpenseParticipant {
  id        String   @id @default(cuid())
  expenseId String
  userId    String

  expense Expense @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([expenseId, userId])
  @@index([userId])
}

// ============== SETTLEMENTS ==============

enum SettlementStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

enum PaymentMethod {
  UPI
  CASH
  OTHER
}

model Settlement {
  id               String           @id @default(cuid())
  fromUserId       String
  toUserId         String
  amount           Decimal         @db.Decimal(12, 2)
  currency         String          @default("INR")
  groupId          String?         // Optional: settle within group context
  status           SettlementStatus @default(PENDING)
  paymentMethod    PaymentMethod?
  upiTransactionId String?         // For UPI deep link / verification
  notes            String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  completedAt      DateTime?

  fromUser User   @relation("SettlementFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User   @relation("SettlementTo", fields: [toUserId], references: [id], onDelete: Cascade)
  group    Group? @relation(fields: [groupId], references: [id], onDelete: SetNull)

  @@index([fromUserId])
  @@index([toUserId])
  @@index([groupId])
  @@index([createdAt])
}

// ============== OTP VERIFICATION ==============

model OTPVerification {
  id         String   @id @default(cuid())
  identifier String   // Email or phone number
  code       String   // 6-digit OTP code
  type       String   // 'email' or 'phone'
  expiresAt  DateTime
  verified   Boolean  @default(false)
  createdAt  DateTime @default(now())
  
  @@index([identifier, type])
  @@index([expiresAt])
}

// ============== CURRENCY EXCHANGE RATES ==============

model ExchangeRate {
  id           String   @id @default(cuid())
  baseCurrency String   // e.g., "USD"
  targetCurrency String // e.g., "INR"
  rate         Decimal  @db.Decimal(18, 6) // Exchange rate
  lastUpdated  DateTime @default(now())
  
  @@unique([baseCurrency, targetCurrency])
  @@index([lastUpdated])
}
